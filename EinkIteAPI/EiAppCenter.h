/* License: COPYING.GPLv3 */
/* Copyright 2019 - present Lenovo */
#pragma once
#include "EiMsgQueue.h"
#include "SvrMsg.h"
#include "itetcon.h"

// 这是SDK的App程序与Service程序的消息交换中心
// 调用Initialize初始化后，执行体的内建线程就会启动起来，持续响应Service发送来的消息，其中一部分效益转为Windows消息发送给App主窗口
// 退出时，调用Relaese函数释放

class CEiAppCenter
{
public:
	CEiMsgQueueListener<CEiSvrMsgItem> moAppListener;
	CEiMsgQueueConnector<CEiSvrMsgItem> moConnectToHost;
	ULONG muAppID;

	CEiAppCenter();
	~CEiAppCenter();

	// 初始化
	ULONG Initialize(TRSP_SYSTEM_INFO_DATA& rSystemInfoData);

	// 释放
	void Release(void);

	// 接收数据回调入口函数
	static void __stdcall AppReciveCallBack(const char* npData, ULONG nSize, void* npContext);
	// 接收数据预处理函数
	void AppPushReciveDataToQueue(const char* npData, ULONG nSize);

	// 回调入口函数
	static void __stdcall AppCenterCallBack(CEiSvrMsgItem& nrMsg, void* npContext);
	// 主分发函数
	void AppDispatch(CEiSvrMsgItem& nrMsg);

	// 发送消息给Service，并等待
	ULONG SendMessageToService(CEiSvrMsgItem& nrMsg);

	// 发送消息和绘制内容给Service，并等待
	ULONG SendMessageToService(CEiSvrMsgItem& nrMsg, EI_BUFFER* npBuffer);

	// 发送消息给Service，不等待
	ULONG PostMessageToService(CEiSvrMsgItem& nrMsg);

	// 发送消息给Service，不等待
	ULONG PostMessageToService(CEiSvrMsgItem& nrMsg, EI_BUFFER* npBuffer);

	// 撤回一类消息，将队列中此类消息全部撤回
	void RecallMessage(const CEiSvrMsgItem& nrMsg);

	//设置接收windows消息的窗口句柄
	void SetHwnd(HWND nHwnd);

	//////////////////////////////////////////////////////////////////////////
	// 以下为具体消息的响应函数
	void MsgBack(CEiSvrMsgItem& nrMsg);

	//获取给绘制用的Buffer地址
	//返回值为地址起始地址，rulBufferSize为Buffer大小
	BYTE* GetBufferBase(ULONG& rulBufferSize);

	// 手指输入消息
	void InputMsg(CEiSvrMsgItem& nrMsg);
	// 全屏重绘
	void ReDraw(CEiSvrMsgItem& nrMsg);
	// Z轴发生变化
	void ZOrderChange(CEiSvrMsgItem& nrMsg);
	// Eink屏幕方向发生变化
	void EinkScreenOrientationChange(CEiSvrMsgItem& nrMsg);
	// 机器形态发生变化
	void LaptopModeChange(CEiSvrMsgItem& nrMsg);
	// 服务通知事件
	void ServiceMsg(CEiSvrMsgItem& nrMsg);
	// homebar状态发生变化
	void HomebarChanged(CEiSvrMsgItem& nrMsg);
	// 键盘样式切换完成
	void KeyboardStyleChangeComplete(CEiSvrMsgItem& nrMsg);
	// 重新设置tp area
	void ResetTPArea(CEiSvrMsgItem& nrMsg);
	// 隐私开关状态发生变化
	void PrivacyStatusChanged(CEiSvrMsgItem& nrMsg);
	// 回应Service端的检测
	void CheckAppAlive(CEiSvrMsgItem& nrMsg);
	// 检查发消息间隔时间是否足够长，超过20秒发送运行正常的消息
	void CheckAndSendNormalRunMsg();
	// smartinfo设置发生了变化
	void SmartInfoSettingChange(CEiSvrMsgItem& nrMsg);

private:
	//获取GUID字符串
	void GetGUIDString(wchar_t* npszBuffer, int niLen);
	//检查服务状态
	bool ProtectService(void);
	// 创建缓存
	void CreateAppBuffer();
	// 释放缓存
	void ReleaseAppBuffer();
	// 读注册表数据
	LSTATUS GetRegSZ(LPCWSTR lpValueName, wchar_t* value);

private:
	// 发送数据缓存
	DWORD muSendBufferLength;
	char* mSendBuffer;

	// add 接收数据缓存
	DWORD muReciveBufferLength;
	char* mpReciveBuffer;

	REG_APP_INFO mdRegAppInfo;

	//接收windows消息的窗口句柄
	HWND mhWnd;
};

